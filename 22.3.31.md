# 题目：

![下载](E:\Desktop\下载.png)

# 答案：

import java.util.Scanner;
public class Main{
	public static void main(String[] args){
	  Scanner sc=new Scanner(System.in);
		long n=sc.nextLong();
		long[] a=new long[44725];
		a[0]=1;
		long k=1l;
		if(n==1){
			System.out.println(1);
			return;
	}
			for(int i=1;i<44725;i++){
				for(int j=i;j>=1;j--){
				 a[j]+=a[j-1];
					if(a[j]==n){
					 System.out.print(k+i-j+1);
						return;
					}
				}
				k+=(i+1);
			}
			System.out.println((n*(n+1)/2)+2);
		

	}

}

# 总结：

1、这道题想了好久，能用一维数组减少内存。

2、（n+1)*n/2>10亿

得出n最大为44725。

先看一下下面这个，是杨辉三角的前8行数据

1    0    0    0    0    0  0  0  0  0  0  0
1    1    0    0    0    0  0  0  0  0  0  0
1    2    1    0    0    0  0  0  0  0  0  0
1    3    3    1    0    0  0  0  0  0  0  0  0  0  0
1    4    6    4    1    0  0  0  0  0  0  0  0  0  0  0
1    5    10  10  5    1  0  0  0  0  0  0  0  0  0  0  0
1    6    15  20  15  6  1  0  0  0  0  0  0  0  0  0  0  0
1    7    21  35  21  7  1  0  0  0  0  0  0  0  0  0  0  0
第一列：永远为1

第二列：从0开始的递增序列

第三列：1+2+3....的累加序列

分析：

第一列始终为1，不管；

第二列为n-1，也不管(你总不可能定义一个十亿行的数组对吧？)

那来看第三列，第三列的值为下图所示:

0
0+0
0+0+1
0+0+1+2
0+0+1+2+3
0+0+1+2+3+4
0+0+1+2+3+4+5
..........
0+0+1+2+........+n
那么，如果说第三列的数值大于10亿了，并且在这之前都没有出现过所需要的值，那么我们是不是就可以判定这个值在第n+1行的第二位数？
而0+0+1+2+...+n>1e9,把前面两个0去除就是一个等差数列，且差值为1

可以求得n为44721；那么加上前面的两个0，就是第44723行数据

为了防止不确定因素，我们给它定为44725可以吧？

那问题又来了，定义一个44725行的二维数组， arr[44725][44725]？

这当然不可能，这样的话会内存超限，那接下来该怎么写呢？

我们可以用记忆化的方法去写着一个代码

每一行都有n个值，第一行1个，第二行2个，第n行n个，那最大行数44725就有44725个数值

借助一下上面的图：

1    0    0    0    0    0  0  0  0  0  0  0
1    1    0    0    0    0  0  0  0  0  0  0
1    2    1    0    0    0  0  0  0  0  0  0
1    3    3    1    0    0  0  0  0  0  0  0  0  0  0
1    4    6    4    1    0  0  0  0  0  0  0  0  0  0  0
1    5    10  10  5    1  0  0  0  0  0  0  0  0  0  0  0
1    6    15  20  15  6  1  0  0  0  0  0  0  0  0  0  0  0
1    7    21  35  21  7  1  0  0  0  0  0  0  0  0  0  0  0

第二行的第二列的1，是不是等于第一行的第二列的0+第一行第一列的1？

第三行第三列的1，等于第二行第三列的0+第二行第二列的1；

第三行第二列的2等于第二行第二列的1+第二行第一列的1；

这样子是不是就是要用到一个二维数组了？

那我们换一个看法，第一行数据怎么变成第二行数据？

arr[1]=1;arr[2]=0;arr[3].......arr[n]=0;

第二列的值初始为0吧?第二行第二列的数是上面两个数的和对吧？

那就是0+arr[1]对吧，也就是arr【2】=0+arr【1】；

那arr【2】初始状态为0，是不是就可以写成：arr【2】=arr【2】+arr【1】？

那从第一行变成第二行后，怎么变成第三行？

arr【3】=arr【3】+arr【2】；

arr【2】=arr【2】+arr【1】；这样是不是就完事了？

那第n行：arr【n】=arr【n】+arr【n-1】；arr【n-1】=arr【n-1】+arr【n-2】........；

那么定义一个数组 ，n从1到44725运行一次判断，是否存在就可以获得正确解

3、怎么将int数组转换为String呢；
public class Demo1_String {
public static void main(String[] args) {
int[]arr= {1,2,23,4,5}; //要转换的int类型数组
String s1=""; //定义一个空字符串
StringBuffer sb=new StringBuffer(s1); //创建字符串缓冲区对象sb，将s1对象传进去（如果不用缓冲区的话，没加一个数组元素，及重新生成一个String对象）
for(int i=0;i<arr.length;i++) {
sb.append(arr[i]); //遍历int数组，追加到sb;
}
String s2=sb.toString(); //返回缓冲区对象的toString(),即得到的字符串
System.out.println(s2);
}
}